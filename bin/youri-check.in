#!/usr/bin/perl
# $Id$

=head1 NAME

youri-check - package check agent

=head1 VERSION

Version 1.0

=head1 SYNOPSIS

youri-check [options] <mode>

Options:

    --config <file>        use file <file> as config file
    --skip-media <media>   skip media <media>
    --skip-test <test>     skip test <test>
    --skip-report <report> skip report <report>
    --parallel             parallel run
    --verbose              verbose run
    --test                 test run
    --list <category>      list items from given category
    --help                 print this help message

=head1 DESCRIPTION

B<youri-check> allows to check packages in a repository.

In test mode, all medias defined in configuration are passed to a list of
test plugins, each of them storing their result in a persistent resultset. In
report mode, this resultset is passed to a list of report plugins, each of them
producing arbitrary effects.

=head1 OPTIONS

=over

=item B<--config> <file>

Use given file as configuration, instead of normal one.

=item B<--skip-media> <media>

Skip media with given identity.

=item B<--skip-test> <test>

Skip test with given identity.

=item B<--skip-report> <report>

Skip report with given identity.

=item B<--parallel>

Run all plugins parallelously

=item B<--verbose>

Produce more verbose report (can be used more than once)

=item B<--test>

Don't perform any modification.

=item B<--list> I<category>

List available items from given category and exits. Category must be either
B<medias>.

=item B<--help>

Print a brief help message and exits.

=back

=head1 CONFIGURATION

Configuration is read from the first file found among:

=over

=item * the one specified by B<--config> option on command-line

=item * $HOME/.youri/check.conf

=item * @sysconfdir@/youri/check.conf

=back

All additional configuration files specified by B<includes> directive are then
processed. Then command line options. Any directive overrides prior definition.

=over

=item B<includes> I<files>

Uses space-separated list I<files> as a list of additional configuration files.

=item B<resolver> I<id>

Declare a maintainer resolver object with identity I<id>.

=item B<preferences> I<id>

Declare a maintainer preferences object with identity I<id>.

=item B<resultset> I<id>

Declare a resultset object with identity I<id>.

=item B<medias> I<ids>

Declares a list of media objects with identity taken in space-separated list
I<ids>.

=item B<tests> I<ids>

Declares a list of test plugin objects with identity taken in space-separated
list I<ids>.

=item B<reports> I<ids>

Declares a list of report plugin objects with identity taken in space-separated
list I<ids>.

=back

Each object declared in configuration must be fully defined later, using a
configuration section, starting with bracketed object identity, followed by at
least a class directive, then any number of additional object-specific
directives.

Example:

        objects = foo
        
        [foo]
        class = Foo::Bar
        key1  = value1
        key2  = value2

=head1 SEE ALSO

Youri::Config, for configuration file format.

Each used plugin man page, for available options.

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2002-2006, YOURI project

This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

=cut

use strict;
use warnings;

use Youri::Config;
use Youri::Utils;
use Pod::Usage;
use Net::Config qw/%NetConfig/;
use DateTime;

my $config = Youri::Config->new(
    command_spec => [
        'skip-test=s@',
        'skip-report=s@',
        'skip-media=s@',
        'parallel!',
        'test|t!',
        'list|l!',
        'verbose|v!'
    ],
    file_spec => [
        'resolver=s',
        'preferences=s',
        'resultset=s',
        'medias=s',
        'tests=s',
        'reports=s'
    ],
    allow_help     => 1,
    allow_config   => 1,
    allow_includes => 1,
    directories => [ "$ENV{HOME}/.youri", '@sysconfdir@/youri' ],
    file_name   => 'check.conf',
    caller => $0,
);

my @media_ids = split(/\s+/, $config->get('medias'));

if ($config->get('list')) {
    my $category = $ARGV[0];
    pod2usage(-verbose => 0, -message => "No category specified, aborting\n")
        unless $category;
    if ($category eq 'medias') {
        print join(' ', @media_ids) . "\n";
    } else {
        pod2usage(-verbose => 0, -message => "Invalid category $category, aborting\n")
    }
    exit 0;
}

pod2usage(
    -verbose => 0,
    -message => "No mode specified, aborting\n"
) unless @ARGV;

my $mode = $ARGV[0];

# convenient global flags
my $test    = $config->get('test');
my $verbose = $config->get('verbose');

# libnet configuration
my %netconfig = $config->get_section('netconfig');
$NetConfig{$_} = $netconfig{$_} foreach keys %netconfig;

# resultset creation
my $resultset_id = $config->get('resultset');
die "No resultset defined" unless $resultset_id;

report("Creating resultset $resultset_id");
my $resultset = create_instance(
    'Youri::Check::Resultset',
    test    => $test,
    verbose => $verbose > 0 ? $verbose - 1 : 0,
    $config->get_section($resultset_id)
);

my $children;

if ($mode eq 'test') {

    # additional objects

    my $resolver;
    my $resolver_id = $config->get('resolver');
    if ($resolver_id) {
        report("Creating maintainer resolver $resolver_id");
        eval {
            $resolver = create_instance(
                'Youri::Check::Maintainer::Resolver',
                test    => $test,
                verbose => $verbose > 1 ? $verbose - 2 : 0,
                $config->get_section($resolver_id)
            );
        };
        print STDERR "Failed to create maintainer resolver $resolver_id: $@\n" if $@;
    }

    my $preferences;
    my $preferences_id = $config->get('preferences');
    if ($preferences_id) {
        report("Creating maintainer preferences $preferences_id");
        eval {
            $preferences = create_instance(
                'Youri::Check::Maintainer::Preferences',
                test      => $test,
                verbose   => $verbose > 1 ? $verbose - 2 : 0,
                $config->get_section($preferences_id)
            );
        };
        print STDERR "Failed to create maintainer preferences $preferences_id: $@\n" if $@;
    }

    my @medias;
    my %skip_medias = map { $_ => 1 } @{$config->get('skip-media')};
    foreach my $id (@media_ids) {
        next if $skip_medias{$id};
        report("Creating media $id");
        eval {
            push(
                @medias,
                 create_instance(
                    'Youri::Media',
                    id      => $id,
                    test    => $test,
                    verbose => $verbose > 0 ? $verbose - 1 : 0,
                    $config->get_section($id)
                )
            );
        };
        print STDERR "Failed to create media $id: $@\n" if $@;
    }

    # prepare resultset
    $resultset->reset();
    $resultset->set_resolver($resolver);

    my %skip_tests = map { $_ => 1 } @{$config->get('skip-test')};
    foreach my $id (split(/\s+/, $config->get('tests'))) {
        next if $skip_tests{$id};
        report("Creating test $id");
        my $test;
        eval {
            $test = create_instance(
                'Youri::Check::Test',
                id         => $id,
                test       => $test,
                verbose    => $verbose > 0 ? $verbose - 1 : 0,
                resolver   => $resolver,
                preferences => $preferences,
                $config->get_section($id)
            );
        };
        if ($@) {
            print STDERR "Failed to create test $id: $@\n";
        } else {
            if ($config->get('parallel')) {
                # fork
                my $pid = fork;
                die "Can't fork: $!" unless defined $pid;
                if ($pid) {
                    # parent process
                    $children++;
                    next;
                }
            }
            eval {
                $test->prepare(@medias);
            };
            if ($@) {
                print STDERR "Failed to prepare test $id: $@\n";
            } else {
                # clone resultset in child process
                $resultset = $config->get('parallel') ?
                    $resultset->clone() :
                    $resultset;

                foreach my $media (@medias) {
                    next if $media->skip_test($id);
                    my $media_id = $media->get_id();
                    report("running test $id on media $media_id");
                    eval {
                        $test->run($media, $resultset);
                    };
                    if ($@) {
                        print STDERR "Failed to run test $id on media $media_id: $@\n";
                    }
                }
            }
            if ($config->get('parallel')) {
                # child process
                exit;
            }
        }
    }

} elsif ($mode eq 'report') {

    my %skip_reports = map { $_ => 1 } @{$config->get('skip-report')};
    foreach my $id (split(/\s+/, $config->get('reports'))) {
        next if $skip_reports{$id};
        report("Creating report $id");
        my $report;
        eval {
            $report = create_instance(
                'Youri::Check::Report',
                id      => $id,
                test    => $test,
                verbose => $verbose > 0 ? $verbose - 1 : 0,
                config  => $config,
                $config->get_section($id)
            );
        };
        if ($@) {
            print STDERR "Failed to create report $id: $@\n";
        } else {
            if ($config->get('parallel')) {
                # fork
                my $pid = fork;
                die "Can't fork: $!" unless defined $pid;
                if ($pid) {
                    # parent process
                    $children++;
                    next;
                }
            }

            # clone resultset in child process
            $resultset = $config->get('parallel') ?
                $resultset->clone() :
                $resultset;

            report("running report $id");
            eval {
                $report->run($resultset);
            };
            if ($@) {
                print STDERR "Failed to run report $id: $@\n";
            }

            if ($config->get('parallel')) {
                # child process
                exit;
            }
        }
    }
} else {
    die "Invalid mode $mode";
}

# wait for all forked processus termination
while ($children) {
    wait;
    $children--;
}

sub report {
    my ($message) = @_;
    print DateTime->now()->strftime('[%H:%M:%S] ')
        if $verbose > 1;
    print "$message\n"
        if $verbose > 0;
}
